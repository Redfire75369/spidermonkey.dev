---
layout: null
---
<!--
   This page is processed by Jekyll and the Liquid templating engine, so this can
   include Liquid expressions.
-->
<!DOCTYPE html>
<html>
  <title>SpiderMonkey Tech Tree</title>
  <link rel="stylesheet" href="/assets/css/normalize.css">
  <link rel="stylesheet" href="/assets/css/style.css">
  <style>
    .mermaid {
      width: 100%;
    }

    .tree {
      width: 90%;
      text-align: center;
      font-size: 300%; /* This only applies to the placeholder text while render
                          happens */
    }

    .text {
      width: 60%;
      margin-left: 10%;
    }

    /* Diagram consumed CSS classes */
    .clickable {
      font-style: italic;
      font-size: 98%; /* Adjust for larger space required by italics */
    }

    .done > * {
      fill: #ceebcf !important;
    }

    .GC > * {
      fill: #faf3c2 !important;
    }

    .JIT > * {
      fill: #ffca61 !important;
    }

    emph {
      font-style: italic;
    }

    #updated {
      margin-right: 10%;
      text-align: right;
    }

  </style>

  <body>
    <h1 class="text">SpiderMonkey Tech Tree</h1>
    <div id="updated"><strong>Last Updated:</strong> {{site.time | date_to_string }} </div>

    <!-- Would be lovely if we could use the MindMap layout, but we can't do
  interaction or links yet https://github.com/mermaid-js/mermaid/issues/4099 -->
    <div id="tree" class="tree">Generating SVG</div>

    <div id="source-link" class="text">
      <a href="./diagram.mmd">(Take a peek at the diagram source)</a>
    </div>

    <p></p>
    <div id="explainer" class="text">
      <strong>What is this?</strong>

      The above diagram is a thinking tool created by the SpiderMonkey Team to plan
      out a series of possible futures. <strong>These are not plans</strong>, so much as
      they are potential routes the project <emph>could</emph> take.
    </div>

    <div id="details" class="text" >
      <h1>Details</h1>
      <h2 id="shapeIndexes">Shape Indexes</h2>
      What if Shapes weren't represented in the object header as a pointer, but
      instead represented in the object header as table index. This by itself
      wouldn't gain us much, but would unlock...

      <h2 id="taggedShapeIndexes">Tagged Shape Indexes</h2>
      Since shapes are immutable, we could tag certain information into their
      Indexes; potentially quite a bit if we were to decide to use a limited
      size of shape index.
      <p>
        For example, Frozen could be inlined into the tag, removing a
        dereference
      </p>

      <h2 id="universalRelazification">Universal Relazification</h2>
      This would be the ability to relazify <i>any</i> script. Currently we can
      only relazify leaf scripts.

      <h2 id="tossBytecode">Regenerate Bytecode For Correctness</h2>
      The ability to relazifiy anything would allow us to start optimizing
      <i>bytecode</i>, (with the large caveat that we'd need to handle
      caseswhere optimized functions are on the stack and who knows what that
      looks like.)

      <h2 id="immutableFlag">Immutable Object Detection at Parse Time</h2>
      In some circumstances we are able to tell that an object is immutable at
      parse time. If the parser could indicate this we might be able to produce
      faster code. See
      <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1830195"
        >Bug 183095 for some previous investigation.</a
      >

      <h2 id="ric">Reusable Inline Caches</h2>
      A
      <a href="https://dl.acm.org/doi/10.1145/3314221.3314587"
        >paper published in 2019</a
      >
      used a data-driven approach to cache and pre-fill inline cache chains on
      applications. We could potentially do something similar once we have a
      disk-cache to store data to.

      <h2 id="inBinaryCode">Embed Generated Code in Binary</h2>
      If we could generate code using our MacroAssembler we could then
      subsequently also use this to replace inline assembly where we currently
      use it.
      <p>
        See
        <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1751204"
          >this bug</a
        >.
      </p>

      <h2 id="smRelocations">SpiderMonkey Relocations</h2>
      In order to be able to generate artifacts to include in our own binaries
      we either need to generate Position/Context/Runtime independent code, or
      we need to support our own form of
      <a href="https://en.wikipedia.org/wiki/Relocation_(computing)"
        >Relocations</a
      >.

      <h2 id="improvedBytecode">Improved Bytecode</h2>
      There is potentially room to improve the performance of our interpreter if
      we were to invest in improving our bytecode. Some techniques to
      investigate woudl be breaking apart ops with dynamic behaviour where the
      dynamism can be identified ahead of time (for example
      <code>GetAliasedVar</code> becoming <code>GetAliasedVar0</code>,
      <code>GetAliasedVar1</code> etc.)
      <p>
        We also could investigate macro ops, which encapsulate sequences that
        have complicated semantics.
      </p>
      <h3>References</h3>
      <ul>
        <li>
          <a href="https://dl.acm.org/doi/10.1145/1899661.1869633">
            <b>Efficient Interpretation with Quickening</b> Stefan Brunthaler
            DLS 2010
          </a>
          and <a href="https://arxiv.org/pdf/2109.02958.pdf">followup</a>.
        </li>
      </ul>

      <h2 id="streamingParsing">Streaming Parsing</h2>
      Right now the Parser as designed must see the whole source text before it
      can parse. It may be beneficial for us to support incremental parsing of a
      text stream, as we could then parse incoming chunks off the network.
    </div>
  </body>

  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10.2/dist/mermaid.esm.mjs";
    let config = {
      // If you have any issues be sure to set log level to at least 3.
      // Lower is more verbose than higher.
      logLevel: 1, // 5 is default.
      flowcharts: {
        useMaxWidth: true,
        htmlLabels: true,
      },
      // Requried for callbacks
      securityLevel: "loose",
    };
    mermaid.initialize(config);
    window.mermaid = mermaid;

    // Cache bust for local development of the diagram.
    const url = "./diagram.mmd";
    const timestamp = new Date().getTime();
    const cacheBustingUrl = `${url}?t=${timestamp}`;

    fetch(cacheBustingUrl)
      .then((response) => {
        if (!response.ok) {
          throw new Error(
            `Failed to load file (status code: ${response.status})`
          );
        }
        let diagram_source = response.text();
        return diagram_source;
      })
      .then(async (diagram_source) => {
        let element = document.querySelector("#tree");
        const { svg, bindFunctions } = await mermaid.render(
          "renderedTree",
          diagram_source
        );
        element.innerHTML = svg;
        if (bindFunctions) {
          bindFunctions(element);
        }
      });

    // Note: Because of how Mermaid works, callbacks need to be referenced relative to
    // window.
    window.callbacks = {
      // Callbacks are invoked with the nodeId as the parameter.
      exampleCallback: function (x) {
        alert("called Callback for " + x);
      },
    };
  </script>
</html>
